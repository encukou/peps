PEP: 285
Title: Adding a bool type
Version: $Revision$
Last-Modified: $Date$
Author: guido@python.org (Guido van Rossum)
Status: Draft
Type: Standards Track
Created: 8-Mar-2002
Python-Version: 2.3
Post-History: 8-Mar-2002


Abstract

    This PEP proposes the introduction of a new built-in type, bool,
    with two constants, False and True.  The bool type would be a
    straightforward subtype (in C) of the int type, and the values
    False and True would behave like 0 and 1 in most respects (e.g.
    False==0 and True==1 would be true) except repr() and str().  All
    built-in operations that conceptually return a Boolean result will
    be changed to return False or True instead of 0 or 1; for example,
    comparisons and the "not" operator.


Rationale

    Most languages eventually grow a Boolean type; even C99 has one.
    It's useful to be able to tell from a function result that the
    outcome has Boolean semantics, and it helps with things like RPC
    protocols that may prefer to encode Booleans differently from
    integers.


Specification

    The following Python code specifies most of the properties of the
    new type:

        class bool(int):

            def __new__(cls, val=0):
                # This constructor doesn't return a new instance;
                # it returns an existing instance
                if val:
                    return True
                else:
                    return False

            def __repr__(self):
                if self:
                    return "True"
                else:
                    return "False"

            __str__ = __repr__

            def __and__(self, other):
                if isinstance(other, bool):
                    return bool(int(self) & int(other))
                else:
                    return NotImplemented

            __rand__ = __and__

            def __or__(self, other):
                if isinstance(other, bool):
                    return bool(int(self) | int(other))
                else:
                    return NotImplemented

            __ror__ = __or__

            def __xor__(self, other):
                if isinstance(other, bool):
                    return bool(int(self) ^ int(other))
                else:
                    return NotImplemented

            __rxor__ = __xor__

        # Bootstrap truth values through sheer willpower
        False = int.__new__(bool, 0)
        True = int.__new__(bool, 1)

    The values False and True will be singletons, like None; the C
    implementation will not allow other instances of bool to be
    created.  At the C level, the existing globals Py_False and
    Py_True will be identical to the built-in singletons False and
    True.

    All built-in operations that are defined to return a Boolean
    result will be changed to return False or True instead of 0 or 1.
    In particular, this affects comparisons (<, <=, ==, !=, >, >=, is,
    is not, in, not it), the unary operator 'not', and built-in
    functions like hasattr(), isinstance() and issubclass(), the dict
    method has_key(), string methods endswith(), isalnum(), isalpha(),
    isdigit(), islower(), isspace(), istitle(), isupper(), and
    startswith(), and the closed attribute of file objects.

    Note that subclassing from int means that True+1 is valid and
    equals 2, and so on.  This is important for backwards
    compatibility: because comparisons and so on currently return
    integer values, there's no way of telling what uses existing
    applications make of these values.


Issues

    Because the repr() or str() of a bool value is different from an
    int value, some code (e.g. doctest-based unit tests, and possibly
    database code that relies on things like "%s" % truthvalue) may
    fail.  How much of a backwards compatibility problem this will be,
    I don't know.  If we find this is a real problem, we could add a
    command-line option to change the repr() and str() of False and
    True to be '0' and '1'; or we could make this the defined
    behavior, but that would defeat some of the purpose (being able to
    see that a printed result is intended to be a truth value).


Copyright

    This document has been placed in the public domain.



Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End:

PEP: 285
Title: Adding a bool type
Version: $Revision$
Last-Modified: $Date$
Author: guido@python.org (Guido van Rossum)
Status: Draft
Type: Standards Track
Created: 8-Mar-2002
Python-Version: 2.3
Post-History: 8-Mar-2002


Abstract

    This PEP proposes the introduction of a new built-in type, bool,
    with two constants, False and True.  The bool type would be a
    straightforward subtype (in C) of the int type, and the values
    False and True would behave like 0 and 1 in most respects (e.g.
    False==0 and True==1 would be true) except repr() and str().  All
    built-in operations that conceptually return a Boolean result will
    be changed to return False or True instead of 0 or 1; for example,
    comparisons and the "not" operator.


Rationale

    Most languages eventually grow a Boolean type; even C99 has one.
    It's useful to be able to tell from a function result that the
    outcome has Boolean semantics.


Specification

    The following Python code specifies most of the properties of the
    new type:

        class bool(int):

            def __new__(cls, val=0, _create=0):
                if _create:
                    # This is nor part of the spec,
                    # just a hack to bootstrap False and True
                    return int.__new__(cls, not not val)
                elif val:
                    return True
                else:
                    return False

            def __repr__(self):
                if self:
                    return "True"
                else:
                    return "False"

            __str__ = __repr__

            def __and__(self, other):
                if isinstance(other, bool):
                    return bool(int(self) & int(other))
                else:
                    return NotImplemented

            __rand__ = __and__

            def __or__(self, other):
                if isinstance(other, bool):
                    return bool(int(self) | int(other))
                else:
                    return NotImplemented

            __ror__ = __or__

            def __xor__(self, other):
                if isinstance(other, bool):
                    return bool(int(self) ^ int(other))
                else:
                    return NotImplemented

            __rxor__ = __xor__


        False = bool(0, _create=1)
        True = bool(1, _create=1)

    The values False and True will be singletons, like None; the C
    implementation will not allow other instances of bool to be
    created.

    All built-in operations that are defined to return a Boolean
    result will be changed to return False or True instead of 0 or 1.
    In particular, this affects comparisons (<, <=, ==, !=, >, >=, is,
    is not, in, not it), the unary operator 'not', and built-in
    functions like hasattr(), isinstance() and issubclass(), the dict
    method has_key(), string methods endswith(), isalnum(), isalpha(),
    isdigit(), islower(), isspace(), istitle(), isupper(), and
    startswith(), and the closed attribute of file objects.


Issues

    Because the repr() or str() of a bool value is different from an
    int value, some code (e.g. doctest-based unit tests) may fail.
    How much of a backwards compatibility problem this will be, I
    don't know.  If we find this is a real problem, we could add a
    command-line option to make False and True aliases for 0 and 1 and
    bool an alias for int.

                                   
Copyright

    This document has been placed in the public domain.



Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End:

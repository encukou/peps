PEP: 318
Title: Function Modifier Syntax
Version: $Revision$
Last-Modified: $Date$
Author: Kevin D. Smith <Kevin.Smith@theMorgue.org>
Status: Draft
Type: Standards Track
Content-Type: text/plain
Created: 05-Jun-2003
Python-Version: 2.4
Post-History:


Abstract
    
    The current method for declaring class and static methods
    is awkward and can lead to code that is difficult to understand.
    This PEP introduces possible new syntax which will place the
    translation of instance methods to class/static methods at
    the same point in the code as the method's declaration. 


Motivation

    The current method of translating an instance method into a 
    class/static method places the actual translation at a different
    point in the code than the declaration of the method.  The 
    code below demonstrates this.

        def foo(self):
            perform method operation
        foo = classmethod(foo)

    When the method is very short, it is easy to look ahead and see
    that this is a class method.  However, if the method is more than
    15 lines or so, the translation into a class method is not 
    obvious.  A solution to this problem is to move the translation
    of the method to the same point as the method's declaration.


Proposal

    Probably the simplest way to place the function that translates
    an instance method to a class/static method is illustrated in the
    code below.

        def classmethod foo(self):
            perform method operation 

    The code in this example will simply perform the following.

        def foo(self):
            perform method operation
        foo = classmethod(foo)
     
    This syntax does not introduce any new keywords and is completely
    backwards compatible with any existing code.  The word between the
    'def' and the actual name of the method is simply a reference to
    a callable object that returns a new function reference. 
    This syntax could also be extended to allow multiple function 
    modifiers in the form of a space delimited list as follows:

       def protected classmethod foo(self):
           perform method operation 

    which would be equivalent to the current form:

       def foo(self):
           perform method operation
       foo = protected(classmethod(foo))

    While this syntax is simple and easy to read, it does become 
    cluttered and more obscure if you wish to allow arguments to be 
    sent to the function modifier.

       def synchronized(lock) classmethod foo(self):
           perform method operation 

    Various syntaxes have been proposed in comp.lang.python.  The
    most common are demonstrated below.

        def foo(self) [synchronized(lock), classmethod]:
            perform method operation

        def foo(self) {'pre': synchronized(lock), 'classmethod': True}:
            """ Skip Montanaro syntax """
            perform method operation

        def foo(self) as synchronized(lock), classmethod:
            """ Gerrit Holl syntax """
            perform method operation

    I have a strong preference for the last of the three.  The first
    two use syntax that just seems arbitrary which does not help the
    user to understand the meaning of it.  The third method is very
    readable and could probably be interpreted easily by those not
    familiar with Python.


Conclusion

    The current method of translating an instance method to a class
    or static method is awkward.  A new syntax for applying function
    modifiers should be implemented (proposed syntax shown below).  

        def foo(self) as synchronized(lock), classmethod:
            perform method operation

    More generally, 

        def foo(self) as <tuple>:
            perform method operation

    The proposed syntax is simple, powerful, easy to read, and 
    therefore preserves those qualities of the Python language.


Copyright

    This document has been placed in the public domain.



Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End:

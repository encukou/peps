PEP: 403
Title: Forward references to anonymous functions and classes
Version: $Revision$
Last-Modified: $Date$
Author: Nick Coghlan <ncoghlan@gmail.com>
Status: Deferred
Type: Standards Track
Content-Type: text/x-rst
Created: 2011-10-13
Python-Version: 3.x
Post-History: 2011-10-13
Resolution: TBD


Abstract
========

This PEP proposes the addition of a new ``in`` statement that allows the use
of the Ellipsis literal (``...``) to make a forward reference to a trailing
anonymous function definition.

This new statement is designed to be used whenever a "one-shot" function is
needed, and the meaning of the function is conveyed clearly by the context
and assigning a name can actually reduce clarity rather than increasing it.

This PEP is based heavily on many of the ideas in PEP 3150 (Statement Local
Namespaces) so some elements of the rationale will be familiar to readers of
that PEP. That PEP has now been withdrawn in favour of this one.


Basic Examples
==============

Before diving into the long history of this problem and the detailed
rationale for this specific proposed solution, here are a few simple
examples of the kind of code it is designed to simplify.

As a trivial example, weakref callbacks could be defined as follows::

    in x = weakref.ref(target, ...)
    def ...(obj):
        print("{} is being destroyed".format(obj))

This contrasts with the current repetitive "out of order" syntax for this
operation::

    def report_destruction(obj):
        print("{} is being destroyed".format(obj))

    x = weakref.ref(target, report_destruction)

That structure is OK when you're using the callable multiple times, but
it's irritating to be forced into it for one-off operations.

Similarly, a sorted operation on a particularly poorly defined type could
now be defined as::

    in sorted_list = sorted(original, key=...)
    def ...(item):
        try:
            return item.calc_sort_order()
        except NotSortableError:
            return float('inf')

Rather than::

    def force_sort(item):
        try:
            return item.calc_sort_order()
        except NotSortableError:
            return float('inf')

    sorted_list = sorted(original, key=force_sort)

And early binding semantics in a list comprehension could be attained via::

    in funcs = [...(i) for i in range(10)]
    def ...(i):
        return lambda x: x + i


Proposal
========

This PEP proposes the addition of a new ``in`` statement that is a variant
of the existing class and function definition syntax.

The new ``in`` clause replaces the decorator lines, and allows forward
references to the trailing function or class definition with the ``...``
literal syntax.

The trailing function or class definition is always anonymous - the provide
a visual link with the forward reference, the ``...`` literal is always
given as the "name" of the class or function.

The ``in`` clause is allowed to contain any simple statement (including those
that don't make any sense in that context - while such code would be legal,
there wouldn't be any point in writing it). This permissive structure is
easier to define and easier to explain, but a more restrictive approach that
only permits operations that "make sense" would also be possible (see PEP
3150 for a list of possible candidates)

The Ellipsis literal ``...`` would be repurposed inside the ``in`` clause
to refer to the anonymous function or class being defined. The Ellipsis
builtin itself can still be accessed by name from an ``in`` clause if
necessary.

As functions or classes defined for an ``in`` statement are always
anonymous, local name binding takes place only if the ``in`` clause
includes an assignment.


Background
==========

The question of "multi-line lambdas" has been a vexing one for many
Python users for a very long time, and it took an exploration of Ruby's
block functionality for me to finally understand why this bugs people
so much: Python's demand that the function be named and introduced
before the operation that needs it breaks the developer's flow of thought.
They get to a point where they go "I need a one-shot operation that does
<X>", and instead of being able to just *say* that, they instead have to back
up, name a function to do <X>, then call that function from the operation
they actually wanted to do in the first place. Lambda expressions can help
sometimes, but they're no substitute for being able to use a full suite.

Ruby's block syntax also heavily inspired the style of the solution in this
PEP, by making it clear that even when limited to *one* anonymous function per
statement, anonymous functions could still be incredibly useful. Consider how
many constructs Python has where one expression is responsible for the bulk of
the heavy lifting:

  * comprehensions, generator expressions, map(), filter()
  * key arguments to sorted(), min(), max()
  * partial function application
  * provision of callbacks (e.g. for weak references)
  * array broadcast operations in NumPy

However, adopting Ruby's block syntax directly won't work for Python, since
the effectiveness of Ruby's blocks relies heavily on various conventions in
the way functions are *defined* (specifically, Ruby's ``yield`` syntax to
call blocks directly and the ``&arg`` mechanism to accept a block as a
function's final argument).

Since Python has relied on named functions for so long, the signatures of
APIs that accept callbacks are far more diverse, thus requiring a solution
that allows anonymous functions to be slotted in at the appropriate location.


Relation to PEP 3150
====================

PEP 3150 (Statement Local Namespaces) described its primary motivation
as being to elevate ordinary assignment statements to be on par with ``class``
and ``def`` statements where the name of the item to be defined is presented
to the reader in advance of the details of how the value of that item is
calculated. This PEP achieves the same goal in a different way, by allowing
the simple name binding of a standard function definition to be replaced
with something else (like assigning the result of the function to a value).

This PEP also achieves most of the other effects described in PEP 3150
without introducing a new brainbending kind of scope. All of the complex
scoping rules in PEP 3150 are replaced in this PEP with a simple forward
reference to the associated function or class definition.


Keyword Choice
==============

The proposal definitely requires *some* kind of prefix to avoid parsing
ambiguity and backwards compatibility problems with existing constructs.
It also needs to be clearly highlighted to readers, since it declares that
the following piece of code is going to be executed out of order.

The ``in`` keyword was chosen as an existing keyword that can be used to
denote the concept of a forward reference.

For functions, the construct is intended to be read as "in <this statement
that references "..."> define "..." as this function".

The mapping to English prose isn't as clean for the class definition case,
but the concept remains the same.


Better Debugging Support for Anonymous Functions and Classes
============================================================

One of the objections to widespread use of lambda expressions is that they
have a negative effect on traceback intelligibility and other aspects of
introspection.

However, the introduction of qualified names in PEP 3155 means that
anonymous functions in different scopes will now have different
representations. For example::

    >>> def f():
    ...     return lambda: y
    ...
    >>> f()
    <function f.<locals>.<lambda> at 0x7f6f46faeae0>

Anonymous function within the *same* scope will still share representations
(aside from the object ID), but this is still a major improvement over the
historical situation where everything *except* the object ID was identical.

The anonymous functions and classes created by the new statement will use
the metaname ``<anon>``.

Syntax Change
=============

New::

    in_stmt: in_prefix (in_classdef|in_funcdef)
    in_prefix: 'in' simple_stmt
    in_funcdef: 'def' '...' parameters ['->' test] ':' suite
    in_classdef: 'class' '...' ['(' [arglist] ')'] ':' suite

Grammar: http://hg.python.org/cpython/file/default/Grammar/Grammar


Possible Implementation Strategy
================================

This proposal has at least one titanic advantage over PEP 3150:
implementation should be relatively straightforward.

The AST for the ``in`` statement will include both the function or class
definition and the statement that references it, so it should just be a
matter of emitting the two operations out of order and using a hidden
variable to link up any references.

The one potentially tricky part is changing the meaning of the Ellipsis
literal notation while within the scope of the ``in`` clause, but that
shouldn't be too hard to address within the compiler.


More Examples
=============

Calculating attributes without polluting the local namespace (from os.py)::

  # Current Python (manual namespace cleanup)
  def _createenviron():
      ... # 27 line function

  environ = _createenviron()
  del _createenviron

  # Becomes:
  in environ = ...()
  def ...():
      ... # 27 line function

Loop early binding::

  # Current Python (default argument hack)
  funcs = [(lambda x, i=i: x + i) for i in range(10)]

  # Becomes:
  in funcs = [...(i) for i in range(10)]
  def ...(i):
    return lambda x: x + i

  # Or even:
  in funcs = [...(i) for i in range(10)]
  def ...(i):
    in return ...
    def ...(x):
        return x + i

Statement local namespace:

  # OK, this definitely looks weird and needs further thought...
  in c = math.sqrt(....a*....a + ....b*....b)
  class ...:
    a = calculate_a()
    b = calculate_b()


Alternative Idea
================

As the statement local namespace example shows, using ```...`` for the
forward reference doesn't play nicely with attribute references on the
anonymous object. The doubly nested example also shows that overuse can
lead to readability disappearing in a mass of dots.

An alternative approach would be to use a similar hidden variable
implementation strategy to implement a *single* statement local variable
for use as the forward reference. Getting the scoping right could be
challenging, but it should still be feasible.

Then the two problematic examples could be written as::

  in funcs = [f(i) for i in range(10)]
  def f(i):
    in return incr
    def incr(x):
        return x + i

  in c = math.sqrt(x.a*x.a + x.b*x.b)
  class x:
    a = calculate_a()
    b = calculate_b()

With the name not actually being bound in the local scope, it isn't
necessary to worry about name collisions, but meaningful names can still be
used to improve readability.


Reference Implementation
========================

None as yet.


Acknowledgements
================

Huge thanks to Gary Bernhardt for being blunt in pointing out that I had no
idea what I was talking about in criticising Ruby's blocks, kicking off a
rather enlightening process of investigation.


Rejected Concepts
=================

A previous incarnation of this PEP (see [1]) proposed a much uglier syntax
that (quite rightly) was not well received. The current proposal is
significantly easier both to read and write.


References
==========

.. [1] Start of python-ideas thread:
   http://mail.python.org/pipermail/python-ideas/2011-October/012276.html


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
